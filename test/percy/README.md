# Visual regression testing with Puppeteer and Percy

We use visual regression testing to avoid inadvertently introducing visual regressions.

This works by taking screenshots of our components in different states. When changes are made, they get compared to the baseline on CI by [Percy](https://percy.io/). In case changes are detected, the CI check will fail unless somebody approves the changes on the Percy website.

- [Scripts overview](#scripts-overview)
  - [Running on CI](#running-on-ci)
  - [Running tests locally to debug components](#running-tests-locally-to-debug-components)
  - [Running tests locally to debug snapshots](#running-tests-locally-to-debug-snapshots)
  - [In detail](#in-detail)
    - [yarn build](#yarn-build)
    - [yarn visual-testing-app:build](#yarn-visual-testing-appbuild)
    - [yarn visual-testing-app:serve](#yarn-visual-testing-appserve)
    - [yarn percy](#yarn-percy)
- [Constraints](#constraints)
  - [How to write visual regressions tests](#how-to-write-visual-regressions-tests)
    - [Create files ending in `.visualroute.js`](#create-files-ending-in-visualroutejs)
    - [Write tests in ending `.visualspec.js`](#write-tests-in-ending-visualspecjs)
  - [Why we test the bundle](#why-we-test-the-bundle)
  - [Why we group multiple states into one snapshot](#why-we-group-multiple-states-into-one-snapshot)
- [Adding Visual Regression Routes](#adding-visual-regression-routes)
- [Adding Visual Regression Tests](#adding-visual-regression-tests)
  - [Suite](#suite)
  - [Spec](#spec)

## Scripts overview

### Running on CI

```bash
# build ui-kit first
yarn build

# now build the visual-testing-app
yarn visual-testing-app:build

# run percy tests
yarn percy --reporters jest-silent-reporter
```

### Debugging components locally

```bash
# build ui-kit in watch mode
yarn build:watch

# now build the visual-testing-app
yarn visual-testing-app:build

# serve the visual-testing-app (this starts a static file server)
# you can make changes to the visual-testing-app or ui-kit and reload the page
# to see changes.
# you can now visit http://localhost:3000 to see what the components look like
yarn visual-testing-app:preview
```

### Running tests locally to debug snapshots

```bash
# build ui-kit in watch mode
yarn build:watch

# now build the visual-testing-app
yarn visual-testing-app:build

# export percy token (you can get it from https://percy.io/commercetools-GmbH/ui-kit/settings)
# percy will use this to upload your local snapshots
export PERCY_TOKEN=foo

# export percy branch
# percy uses this to establish the baseline, usually you'll always use "local"
export PERCY_BRANCH=local

# run percy tests
# Once its done it will print a URL which lets you review the visual diffs
yarn percy
```

You'll notice that we're not serving `visual-testing-app` here. Puppeteer does that for us, see `just-puppeteer.config.js`.

### In detail

#### `yarn build`

Builds the ui-kit. Since visual-regression-testing uses the final ui-kit bundle,
you need to run this or `yarn build:watch` before starting the tests.

#### `yarn visual-testing-app:start`

This starts the visual-testing-application in development mode. It needs to be run before starting
the visual regression tests.

#### `yarn visual-testing-app:build`

This builds the visual-testing-application. It needs to be run before starting
the visual regression tests.

#### `yarn visual-testing-app:preview`

This command is useful for debugging tests locally. This serves the visual-testing-application, but you need to build it first using `yarn visual-testing-app:build`!

It starts a local web server which you can visit to see what the routes look like in your browser.

#### `yarn percy`

This runs the puppeteer tests and captures results using percy.

If you're running this locally, make sure you have `PERCY_TOKEN` and `PERCY_BRANCH` exported (see below). Otherwise you'll be warned with `Warning: Skipping visual tests. PERCY_TOKEN was not provided.` and no snapshots will be taken.

Locally, you can run `yarn percy` without having `PERCY_TOKEN` and `PERCY_BRANCH` exported in case you only want to verify the puppeteer setup.

## Constraints

### How to write visual regressions tests

#### Create files ending in `.visualroute.js`

Our `visual-testing-app` detects all files ending in `.visualroute.js`, and creates a route for each of these files. We can then use these routes in our test files ending in `visualspec.js`

#### Write tests in ending `.visualspec.js`

We use a library called [jest-puppeteer](https://github.com/smooth-code/jest-puppeteer) to run our visual tests. We use puppeteer to navigate to routes generated by our `*.visualroute.js` files, and then we use a tool called [Percy](https://percy.io/) to take snapshots of that route.

### Why we test the bundle

We use the bundled ui-kit to ensure that rollup bundling is working well. This allows us to quickly ensure changes to the rollup build don't break the visuals of our components.

### Why we group multiple states into one snapshot

When writing visual regression tests we need to ensure that we stay within our monthly budget of visual diffs on Percy. Every time a screenshot is taken for a specific browser and a specific viewport it counts as one _visual diff_. Another factor to consider is that we want to ensure that Percy completes in a timely manner. Taking one snapshot takes around 3 seconds. If we take one snapshot for every state of every component, then it quickly adds up to over 45 minutes to complete a single test run. We therefore render one component in many states in a single snapshot. We also limit ourselves to one browser and one viewport size to reduce the number of visual diffs created per test run.

## Adding Visual Regression Routes

Below is an example of how to add Visual Regression Route to the Visual Testing Playground. This section also demonstrates the components we've built to ease writing tests.

All visual routes must import from the bundled ui-kit. This rule is introduced to ensure that the rollup build chain is tested as well - which gives us more confidence when making changes to rollup itself.

```js
// primary-button.visualroute.js

import { InformationIcon, PrimaryButton } from '@commercetools-frontend/ui-kit';
import { Suite, Spec } from '../../../../test/percy';

export const routePath = '/primary-button';

export const component = () => (
  <Suite>
    <Spec label="in default state">
      <PrimaryButton label="Primary button" />
    </Spec>
    <Spec label="when disabled">
      <PrimaryButton disabled={true} label="Primary button" />
    </Spec>
  </Suite>
);
```

You can see your route by running `yarn visual-testing-app:build` and `yarn visual-testing-app:serve` and then navigating to your defined routePath.

## Adding Visual Regression Tests

Below is an example of how to add Visual Regression Test.

```js
// primary-button.visualspec.js

import percySnapshot from '@percy/puppeteer';

describe('PrimaryButton', () => {
  beforeAll(async () => {
    await page.goto(`${globalThis.HOST}/primary-button`);
  });

  it('PrimaryButton', async () => {
    await expect(page).toMatch('A label text');
    await percySnapshot(page, 'PrimaryButton');
  });
});
```

You can run your test by running `yarn percy`. Notice how before we call `percySnapshot`, we add an expect assertion on some text on the page. This is to ensure that the tests will fail if your route cannot be found. Otherwise, we could end up uploading a lot of `route not founds` to Percy.

### `Suite`

The `Suite` sets up the context (`react-intl`) for the tests. It should always be rendered even when your component doesn't access these things.

You should only use one `Suite` per `screenshot` as there is no point in defining multiple `Suites` since you only need the context to be set up once (usually). An exception might be if you want to render your component in multiple locales.

### `Spec`

A `Spec` should render your component in a specific state.

You may use the prop `propsToList` to specify which props you want to display within the snapshot. Ideally, these should be the ones which you are testing. If `propsToList` is not defined, every prop will be displayed.
If don't want to display any props at all, use `omitPropsList`.

You may use the `testedThemes` prop to specify which themes will be used to showcase the component. By default, the component is rendered in both the default theme of the application and a local `ThemeProvider` context is created to showcase the component in the `new` theme. In order to only use the default (`old`) or the `new` theme context use `testedThemes={["old"]}` or `testedThemes={["new"]}` respectively.
For specific use cases, like testing `ThemeProvider`, you may want to use `testedThemes={[]}` which will use the global theming context and not show any theme label.

If you want to display the props of a nested component which is wrapped by the direct child of your `Spec`, use `listPropsOfChild`. This can be useful if you need to wrap your component in a `ThemeProvider`.

You can use multiple specs within a `Suite`.
