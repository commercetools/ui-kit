const fs = require('fs');
const path = require('path');
const yaml = require('yaml');
const camelCase = require('lodash.camelcase');
const prettier = require('prettier');
const rcfile = require('rcfile');

const prettierConfig = rcfile('prettier');

const definitions = yaml.parse(
  fs.readFileSync(
    path.join(__dirname, '../materials/internals/definition.yaml'),
    'utf8'
  )
);

const endProgram = message => {
  // eslint-disable-next-line no-console
  console.error(`Custom Properties Error: ${message}`);
  process.exit(1);
};

const TOKEN_REGEX = /^(\w+(?:-\w+)(?:-\w+)?)(?:-for-(\w+(?:-\w+)?))?(?:-when-([\w-]+?))?(?:-on-([\w-]+?))?$/i;

const supportedStates = Object.keys(definitions.states);
const supportedComponentGroups = Object.keys(definitions.componentGroups);

const tokens = {};

Object.values(definitions.choiceGroups).forEach(choiceGroup => {
  Object.entries(choiceGroup.choices).forEach(([key, value]) => {
    if (tokens[key]) endProgram(`Token "${key} already exists!"`);

    if (key !== key.toLowerCase())
      endProgram(`Tokens "${key}" must be lower case`);

    if (!key.startsWith(choiceGroup.prefix))
      endProgram(
        `Expected token "${key}" to start with "${
          choiceGroup.prefix
        }" as it is an "${choiceGroup.label}" attribute.`
      );

    tokens[key] = value;
  });
});

Object.values(definitions.decisionGroups).forEach(decisionGroup => {
  Object.entries(decisionGroup.decisions).forEach(([key, decision]) => {
    if (tokens[key]) endProgram(`Token "${key} already exists!"`);
    if (key !== key.toLowerCase())
      endProgram(`Tokens "${key}" must be lower case`);
    if (!decision.choice) {
      endProgram(`You forgot to specify a choice for ${decision}`);
    }
    if (!tokens[decision.choice]) {
      endProgram(`Choice called "${decision.choice}" was not found!`);
    }
    // TODO parse token name and warn when invalid name was given and token
    // is not deprecated

    const match = key.match(TOKEN_REGEX);

    if (match) {
      const componentGroup = match[2];
      const state = match[3];

      if (componentGroup && !supportedComponentGroups.includes(componentGroup))
        endProgram(
          `Token "${key}" uses unsupported component group "${componentGroup}"!`
        );

      if (state && !supportedStates.includes(state))
        endProgram(`Token "${key}" uses unsupported state "${state}"!`);
    } else if (!decision.deprecated) {
      endProgram(
        `Token "${key}" does not follow <attribute>-for-<component-group>-when-<state>-on-dark naming scheme! Tokens not following this scheme must use "deprecated" flag.`
      );
    }

    tokens[key] = tokens[decision.choice];
  });
});

// Copy over plain tokens
Object.entries(definitions.plainTokens).forEach(([key, value]) => {
  if (tokens[key]) endProgram(`Token called "${key} already exists!"`);

  tokens[key] = value;
});

// Write files
const printJson = data =>
  JSON.stringify(
    Object.entries(data).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [`--${key}`]: value,
      }),
      {}
    )
  );

const printJavaScript = data => `
/*
  THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

  This file is created by the 'scripts/generate-custom-properties.js' script.
  The variables should be updated in 'materials/internals/definition.yaml'.
*/

export default {
${Object.entries(data)
  .map(([key, value]) => `${camelCase(key)}: "${value}",`)
  .join('\n')}
};
`;

const printCss = data => `
/*
  THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

  This file is created by the 'scripts/generate-custom-properties.js' script.
  The variables should be updated in 'materials/internals/definition.yaml'.
*/

:root {
  ${Object.entries(data)
    .map(([key, value]) => `--${key}: ${value};`)
    .join('\n')}
}
`;

const printReasonMl = data => `
/*
  THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

  This file is created by the 'scripts/generate-custom-properties.js' script.
  The variables should be updated in 'materials/internals/definition.yaml'.
*/

open Css;

${Object.entries(data)
  .map(([key, value]) => {
    if (key.startsWith('color') || key.includes('color')) {
      if (/^#/.test(value))
        return `let ${camelCase(key)} = color(\`hex("${value.replace(
          /^#/,
          ''
        )}"));`;
      if (/^hsl/.test(value)) {
        const colorParts = value
          .replace(/^hsl\((.*),(.*)%,(.*)%\)$/, '$1,$2,$3')
          .split(',')
          .map(num => (Number.isSafeInteger(num) ? num : Math.round(num)));
        return `let ${camelCase(key)} = color(\`hsl(${colorParts[0]}, ${
          colorParts[1]
        }, ${colorParts[2]}));`;
      }
      return `let ${camelCase(key)} = \`definition("color", "${value}")`;
    }
    if (key.startsWith('border-radius')) {
      return `let ${camelCase(
        key
      )} = \`definition("border-radius", "${value}")`;
    }
    if (key.startsWith('font-family')) {
      return `let ${camelCase(key)} = \`definition("font-family", "${value}")`;
    }
    if (key.startsWith('font-size')) {
      return `let ${camelCase(key)} = \`definition("font-size", "${value}")`;
    }
    if (key.startsWith('shadow-box')) {
      return `let ${camelCase(key)} = \`definition("box-shadow", "${value}");`;
    }
    if (key.startsWith('shadow')) {
      const shadowDef = `let ${camelCase(key)} = "${value}";`;
      const shadowBoxDef = `let ${camelCase(
        `box-${key}`
      )} = \`definition("box-shadow", "${value}");`;
      return `${shadowDef}\n${shadowBoxDef}`;
    }
    if (
      key.startsWith('constraint') ||
      key.startsWith('spacing') ||
      key.startsWith('break-point') ||
      key.includes('height')
    ) {
      if (/%$/.test(value))
        return `let ${camelCase(key)} = \`percent(${value.replace(/%$/, '')});`;
      return `let ${camelCase(key)} = \`px(${value.replace(/px$/, '')});`;
    }
    if (key.startsWith('transition')) {
      return `let ${camelCase(key)} = \`definition("transition", "${value}")`;
    }
    return `let ${camelCase(key)} = "${value}";`;
  })
  .join('\n')}
`;

fs.writeFileSync(
  path.join(__dirname, '../materials/custom-properties.json'),
  prettier.format(printJson(tokens), {
    ...prettierConfig,
    parser: 'json',
  })
);

fs.writeFileSync(
  path.join(__dirname, '../materials/custom-properties.js'),
  prettier.format(printJavaScript(tokens), prettierConfig)
);

fs.writeFileSync(
  path.join(__dirname, '../materials/custom-properties.css'),
  prettier.format(printCss(tokens), {
    ...prettierConfig,
    parser: 'css',
  })
);

fs.writeFileSync(
  path.join(__dirname, '../materials/CustomProperties.re'),
  printReasonMl(tokens)
);
